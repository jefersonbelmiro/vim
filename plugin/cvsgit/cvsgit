#!/usr/bin/php -q 
<?php
/**
 * -----------------------------------------------------------------------------
 * cvsgit - Algumas Funcionalidas do GIT para CVS
 * -----------------------------------------------------------------------------
 *
 * @require phpcli
 * @require cvs client
 * @version 0.1
 * -----------------------------------------------------------------------------
 */

/**
 * Caminha da home 
 */
if ( getenv('HOME') != '' ) {
  CvsGit::$sDiretorioObjetos = getenv('HOME') . '/' . CvsGit::$sDiretorioObjetos;
} 

/**
 * remove primeiro indice com nome do arquivo atual 
 */
array_shift($argv);

/**
 * argumentos passados para o script
 */
$aArgumentos = $argv;

/**
 * Opcao a ser executada
 */
$sOpcao = array_shift($aArgumentos);

/**
 * verifica qual metodo chamar 
 */
switch ($sOpcao) {

  default : 

    CvsGit::output("Nenhum comando informado", 'aviso');
    CvsGit::output(" Usar: cvsgit [comando] [opcoes do comando]");
    CvsGit::output(" Comandos: status, add, init, push, pull, rm e log\n");

  break;

  case 'status' :
    CvsGit::status($aArgumentos);
  break;

  case 'add':
  case 'commit':
    CvsGit::adicionar($aArgumentos);
  break;

  case 'init':
    CvsGit::iniciar($aArgumentos);
  break;

  case 'log':
    CvsGit::log($aArgumentos);
  break;

  case 'logvim':
    CvsGit::logVim($aArgumentos);
  break;

  case 'rm':
    CvsGit::remover($aArgumentos);
  break;

  case 'push' :
    CvsGit::push();
  break;

  case 'pull' :
    CvsGit::pull();
  break;
}

class CvsGit {
  
  public static $sDiretorioObjetos = '.vim/plugin/cvsgit/objects/';

  /**
   * Tipos de commit  
   */
  public static $aTiposCommit = array(

    /**
     * Tem arquivo no projeto mas nao no servidor, cvs add
     */
    '?' => 'Novo', 

    /**
     * Tem alteracoes que nao tem no servidor 
     */
    'M' => 'Modificado',

    /**
     * Conflito, e cvs tentou fazer merge
     * cvs altera arquivo colocando as diferencas 
     */
    'C' => 'Conflito',

    /**
     * modificado no servidor
     * versao do servidor Ã© maior que a do projeto 
     */
    'U' => 'Atualizado',

    /**
     * Igual U, diferenca que servidor manda um path 
     */
    'P' => 'Atualizado',

    /**
     * Apos dar cvs add, arquivo pronto para ser comitado 
     */
    'A' => 'Adicionado',

    /**
     * Apos remover arquivo do projeto, ira remover do servidor se for commitado 
     */
    'R' => '-Removido'
  );

  public static function output($sMensagem, $sPerfil = null) {

    switch( $sPerfil ) {

      case 'erro' :
        $sMensagem = "\n " . Shell::colorString($sMensagem, 'red') . "\n";
      break;

      case 'aviso' : 
        $sMensagem = "\n " . $sMensagem . "\n";
      break;
    }

    echo Encode::toUTF8($sMensagem . "\n");
  }

  private static function getProjeto() {

    if ( !file_exists(self::$sDiretorioObjetos . 'Objects') ) {

      self::output(getcwd() . " nÃ£o inicializado");
      exit(1);
    }

    $aProjetos = unserialize(file_get_contents(self::$sDiretorioObjetos . 'Objects'));
    $sDiretorioAtual = getcwd();

    foreach ($aProjetos as $sProjeto) {

      if ( strpos($sDiretorioAtual, $sProjeto) !== false && strpos($sDiretorioAtual, $sProjeto) == 0 ) {
        return $sProjeto;
      }
    }

    self::output(getcwd() . " nÃ£o inicializado");
    exit(1);
  }

  private static function getArquivos() {
    
    $sDiretorioProjeto = self::getProjeto();
    $sDiretorioObjetos = self::$sDiretorioObjetos . md5($sDiretorioProjeto);

    if ( !file_exists($sDiretorioObjetos) ) {
      return array();
    }

    return unserialize(file_get_contents($sDiretorioObjetos));
  }

  private static function setArquivos(Array $aArquivos) {

    $sDiretorioProjeto = self::getProjeto();
    $sDiretorioObjetos = self::$sDiretorioObjetos . md5($sDiretorioProjeto);

    return file_put_contents($sDiretorioObjetos, serialize($aArquivos));
  }

  /**
   * Inicia um projeto
   *
   * @static
   * @access public
   * @return void
   */
  public static function iniciar($aParametros = array()) {

    if ( !file_exists(self::$sDiretorioObjetos . 'Objects') ) {
      file_put_contents(self::$sDiretorioObjetos . 'Objects', serialize(array()));
    }

    $aProjetos = unserialize(file_get_contents(self::$sDiretorioObjetos . 'Objects'));
    $sDiretorioAtual = getcwd();

    if ( in_array($sDiretorioAtual, $aProjetos) ) {
      return true;
    }   

    $aProjetos[] = $sDiretorioAtual;
    file_put_contents(self::$sDiretorioObjetos . 'Objects', serialize($aProjetos));
  }

  /**
   * log
   *
   * @static
   * @access public
   * @return void
   */
  public static function logVim($aParametros) {

    if ( empty($aParametros) ) {

      self::output('Nenhum parametro informado');
      return;
    }

    // @todo aceitar varios arquivos
    foreach ($aParametros as $iIndice => $sParametro) {

      if ( file_exists($sParametro) ) {

        $sArquivo = $sParametro;
        break;
      }
    }

    if ( empty($sArquivo) ) {

      self::output('arquivo nao econtrado');
      return;
    } 

    $sArquivo = str_replace(getcwd() . '/', '', $sArquivo);

    /**
     * Lista somenta as tags
     */
    exec('cvs log -h ' . $sArquivo . ' 2> /tmp/cvslog-header-error', $aRetornoComandoTags, $iStatusComandoTags);

    if ( $iStatusComandoTags > 0 ) {

      self::output('Erro ao execurar cvs log -h ' . $sArquivo, 'erro');
      return;
    }

    $aTagsPorVersao = array();
    $iVersaoAtual = 0;
    $lInicioListaTags = false;

    foreach( $aRetornoComandoTags as $iIndiceTags => $sLinhaRetornoTag ) {

      if ( strpos($sLinhaRetornoTag, 'head:') !== false ) {

        $iVersaoAtual = trim(str_replace('head:', '', $sLinhaRetornoTag));
        continue;
      }

      if ( strpos($sLinhaRetornoTag, 'symbolic names:') !== false ) {

        $lInicioListaTags = true;
        continue;
      }

      if ( $lInicioListaTags ) {

        if ( strpos($sLinhaRetornoTag, 'keyword substitution') !== false ) {
          break;
        }

        if ( strpos($sLinhaRetornoTag, 'total revisions') !== false ) {
          break;
        }

        $aLinhaTag = explode(':', $sLinhaRetornoTag);
        $iVersao   = trim($aLinhaTag[1]);
        $sTag      = trim($aLinhaTag[0]);

        $aTagsPorVersao[$iVersao][] = $sTag;
      }
    }

    /**
     * Lista informacoes do commit, sem as tags
     */
    exec('cvs log -N ' . $sArquivo . ' 2> /tmp/cvslog-info-error', $aRetornoComandoInformacoes, $iStatusComandoInformacoes);

    if ( $iStatusComandoInformacoes > 1 ) {

      self::output('Erro ao execurar cvs log -N ' . $sArquivo, 'erro');
      return;
    }

    $aLog = array();
    $iLinhaInformacaoCommit = 0;

    $oTabela = new Table();
    $oTabela->setHeaders(array('1', '2', '3', '4', '5'));
    $aLinhas = array();

    $iVersao   = null;
    $sAutor    = null;
    $sData     = null;
    $sMensagem = null;

    foreach ( $aRetornoComandoInformacoes as $iIndice => $sLinhaRetorno ) {

      if ( strpos($sLinhaRetorno, '------') !== false ) {
        continue;
      } 

      if ( $iLinhaInformacaoCommit == 0 && $iIndice > 11 ) {

        $sTagsPorVersao = null;

        if ( !empty($aTagsPorVersao[$iVersao]) ) {
          $sTagsPorVersao = implode(', ', $aTagsPorVersao[$iVersao]);
        }

        $oTabela->addRow(array($iVersao, $sTagsPorVersao, $sAutor, $sData, $sMensagem));
        $iVersao   = '';
        $sAutor    = '';
        $sData     = '';
        $sMensagem = '';
      }

      if ( $iLinhaInformacaoCommit > 0 ) {
        $iLinhaInformacaoCommit--;
      } 

      /**
       * Versao
       */
      if ( strpos($sLinhaRetorno, 'revision') !== false && strpos($sLinhaRetorno, 'revision') === 0 ) {
        $iLinhaInformacaoCommit = 2;
      } 
      
      /**
       * Versao
       */
      if ( $iLinhaInformacaoCommit == 2 ) {

        $iVersao = trim(str_replace('revision', '', $sLinhaRetorno));
        continue;
      }

      /**
       * Data e autor 
       */
      if ( $iLinhaInformacaoCommit == 1 ) {
        
        $sLinhaRetorno = strtr($sLinhaRetorno, array('date:' => '', 'author:' => ''));
        $aLinhaInformacoesCommit = explode(';', $sLinhaRetorno);
        $sLinhaData = array_shift($aLinhaInformacoesCommit);
        $aLinhaData = explode(' ', $sLinhaData);
        $sData .= implode('/', array_reverse(explode('/', $aLinhaData[1])));

        $sAutor = trim(array_shift($aLinhaInformacoesCommit));
        continue;
      } 

      /**
       * Mensagem 
       */
      if ( $iLinhaInformacaoCommit == 0 ) {
        $sMensagem = $sLinhaRetorno;
      }
    }

    $sLog = trim($oTabela->render( $mostra_com_espacos = true )) . "\n";

    file_put_contents('/tmp/cvslogvim', Encode::toISO($sLog));

    return $sLog;
  }

  /**
   * log
   *
   * @static
   * @access public
   * @return void
   */
  public static function log($aParametros) {

    if ( empty($aParametros) ) {

      self::output('Nenhum parametro informado');
      return;
    }

    // @todo aceitar varios arquivos
    foreach ($aParametros as $iIndice => $sParametro) {

      if ( file_exists($sParametro) ) {

        $sArquivo = $sParametro;
        break;
      }
    }

    if ( empty($sArquivo) ) {

      self::output('arquivo nao econtrado');
      return;
    } 

    $sArquivo = str_replace(getcwd() . '/', '', $sArquivo);

    /**
     * Lista somenta as tags
     */
    exec('cvs log -h ' . $sArquivo . ' 2> /tmp/cvslog-header-error', $aRetornoComandoTags, $iStatusComandoTags);

    if ( $iStatusComandoTags > 0 ) {

      self::output('Erro ao execurar cvs log -h ' . $sArquivo, 'erro');
      return;
    }

    $aTagsPorVersao = array();
    $iVersaoAtual = 0;
    $lInicioListaTags = false;

    foreach( $aRetornoComandoTags as $iIndiceTags => $sLinhaRetornoTag ) {

      if ( strpos($sLinhaRetornoTag, 'head:') !== false ) {

        $iVersaoAtual = trim(str_replace('head:', '', $sLinhaRetornoTag));
        continue;
      }

      if ( strpos($sLinhaRetornoTag, 'symbolic names:') !== false ) {

        $lInicioListaTags = true;
        continue;
      }

      if ( $lInicioListaTags ) {

        if ( strpos($sLinhaRetornoTag, 'keyword substitution') !== false ) {
          break;
        }

        if ( strpos($sLinhaRetornoTag, 'total revisions') !== false ) {
          break;
        }

        $aLinhaTag = explode(':', $sLinhaRetornoTag);
        $iVersao   = trim($aLinhaTag[1]);
        $sTag      = trim($aLinhaTag[0]);

        $aTagsPorVersao[$iVersao][] = $sTag;
      }
    }

    /**
     * Lista informacoes do commit, sem as tags
     */
    exec('cvs log -N ' . $sArquivo . ' 2> /tmp/cvslog-info-error', $aRetornoComandoInformacoes, $iStatusComandoInformacoes);

    if ( $iStatusComandoInformacoes > 0 ) {

      self::output('Erro ao execurar cvs log -N ' . $sArquivo, 'erro');
      return;
    }

    $aLog = array();
    $iLinhaInformacaoCommit = 0;

    $oTabela = new Table();
    $oTabela->setHeaders(array('Autor', 'Data', 'Versao', 'Tag', 'Mensagem'));
    $aLinhas = array();

    $iVersao   = null;
    $sAutor    = null;
    $sData     = null;
    $sMensagem = null;

    foreach ( $aRetornoComandoInformacoes as $iIndice => $sLinhaRetorno ) {

      if ( strpos($sLinhaRetorno, '------') !== false ) {
        continue;
      } 

      if ( $iLinhaInformacaoCommit == 0 && $iIndice > 11 ) {

        $sTagsPorVersao = null;

        if ( !empty($aTagsPorVersao[$iVersao]) ) {
          $sTagsPorVersao = implode(', ', $aTagsPorVersao[$iVersao]);
        }

        if ( $iVersao == $iVersaoAtual ) {
          $iVersao .= '*';
        } 

        $oTabela->addRow(array($sAutor, $sData, $iVersao, $sTagsPorVersao, $sMensagem));
        $iVersao   = '';
        $sAutor    = '';
        $sData     = '';
        $sMensagem = '';
      }

      if ( $iLinhaInformacaoCommit > 0 ) {
        $iLinhaInformacaoCommit--;
      } 

      /**
       * Versao
       */
      if ( strpos($sLinhaRetorno, 'revision') !== false && strpos($sLinhaRetorno, 'revision') === 0 ) {
        $iLinhaInformacaoCommit = 2;
      } 
      
      /**
       * Versao
       */
      if ( $iLinhaInformacaoCommit == 2 ) {

        $iVersao = trim(str_replace('revision', '', $sLinhaRetorno));
        continue;
      }

      /**
       * Data e autor 
       */
      if ( $iLinhaInformacaoCommit == 1 ) {
        
        $sLinhaRetorno = strtr($sLinhaRetorno, array('date:' => '', 'author:' => ''));
        $aLinhaInformacoesCommit = explode(';', $sLinhaRetorno);
        $sLinhaData = array_shift($aLinhaInformacoesCommit);
        $aLinhaData = explode(' ', $sLinhaData);
        $sData .= implode('/', array_reverse(explode('/', $aLinhaData[1])));

        $sAutor = trim(array_shift($aLinhaInformacoesCommit));
        continue;
      } 

      /**
       * Mensagem 
       */
      if ( $iLinhaInformacaoCommit == 0 ) {
        $sMensagem = $sLinhaRetorno;
      }
    }

    self::output($oTabela->render());
  }

  public static function push() {

    $aArquivos = self::getArquivos();

    if ( empty($aArquivos) ) {

      self::output("Nenhum arquivo para comitar");
      return;
    }

    $oTabela = new Table();
    $oTabela->setHeaders(array('Arquivo', 'Tag', 'Mensagem', 'Tipo'));
    $aLinhas = array();
    $aComandos = array();
    $iErros  = 0;

    foreach ( $aArquivos as $oCommit ) {

      $sArquivo      = self::clearPath($oCommit->sArquivo);
      $iTag          = $oCommit->iTag;
      $sMensagem     = $oCommit->sMensagem;
      $sTipoCompleto = $oCommit->sTipoCompleto;
      $sErro         = Shell::colorString('[x]', 'red');

      if ( !file_exists($oCommit->sArquivo) ) {

        $sArquivo = $sErro . $sArquivo;
        $iErros++;
      }

      if ( empty($oCommit->sMensagem) ) {

        $sMensagem = $sErro;
        $iErros++;
      }

      if ( empty($oCommit->iTag) || mb_strlen($oCommit->iTag, 'utf8') < 4 ) {

        $iTag = $sErro;
        $iErros++;
      }

      if ( empty($oCommit->sTipoAbreviado) || empty($oCommit->sTipoCompleto) ) {

        $sTipoCompleto = $sErro;
        $iErros++;
      }

      $oTabela->addRow(array($sArquivo, $iTag, $sMensagem, $sTipoCompleto));

      $aComandos[ $oCommit->sArquivo ][] = $oCommit;
    }

    if ( $iErros > 0 ) {

      self::output("\n " . $iErros . " erro(s) encontrado(s):");
      self::output($oTabela->render());
      return;
    }

    echo "\n";

    foreach($aComandos as $sArquivo => $aCommits) {

      foreach($aCommits as $oCommit) {

        $sComandoCommit = "cvs commit -m '$oCommit->sTipoAbreviado: $oCommit->sMensagem ($oCommit->sTipoCompleto #$oCommit->iTag)' " . self::clearPath($oCommit->sArquivo);
        $sComandoTag    = "cvs tag -F T{$oCommit->iTag} " . self::clearPath($oCommit->sArquivo);

        self::output("-- " . self::clearPath($sArquivo) . ": ");
        self::output("   " . Encode::UTF8ToISO($sComandoCommit));
        self::output("   " . Encode::UTF8ToISO($sComandoTag));
      }

      echo "\n";
    }

    $sLine = readline('Commitar?: (s/N): ');

    if ( strtoupper($sLine) != 'S' ) {
      exit;
    } 

    echo "\n";

    foreach($aComandos as $sArquivo => $aCommits) {

      foreach($aCommits as $oCommit) {

        $sComandoCommit = "cvs commit -m '$oCommit->sTipoAbreviado: $oCommit->sMensagem ($oCommit->sTipoCompleto #$oCommit->iTag)' " . self::clearPath($oCommit->sArquivo) . " 2> /tmp/cvscommit_" . basename($oCommit->sArquivo);
        $sComandoTag    = "cvs tag -F T{$oCommit->iTag} " . self::clearPath($oCommit->sArquivo). " 2> /tmp/cvstag_" . basename($oCommit->sArquivo);

        exec( Encode::UTF8ToISO($sComandoCommit), $aRetornoComandoCommit, $iStatusComandoCommit );
        exec( Encode::UTF8ToISO($sComandoTag), $aRetornoComandoTag, $iStatusComandoTag );

        if ( $iStatusComandoCommit > 0 ) {

          self::output('Erro ao commitar arquivo: ' . self::clearPath($oCommit->sArquivo), 'erro');
          continue;
        }

        if ( $iStatusComandoTag > 0 ) {

          self::output('Erro ao por tag no arquivo: ' . self::clearPath($oCommit->sArquivo), 'erro');
          continue;
        }
        
        self::output(Shell::colorString(self::clearPath($oCommit->sArquivo) . ' - commitado', 'green'));
        self::remover(array($oCommit->sArquivo));
      }

    }

    echo "\n";

  }

  /**
   * Remover arquivo da lista de arquivos para commit
   *
   * @param Array $aParametros
   * @static
   * @access public
   * @return void
   */
  public static function remover($aParametros) {

    $aArquivos = self::getArquivos();

    foreach ( $aParametros as $sParametro ) {

      if ( in_array($sParametro, array('.', '*', 'all')) ) {

        $aArquivos = array();
        break;
      }

      if ( !empty($aArquivos[$sParametro]) || in_array($sParametro, array('.', '*', 'all')) ) {
        unset($aArquivos[$sParametro]);
      }

      if ( !empty($aArquivos[getcwd() . '/' . $sParametro]) ) {
        unset($aArquivos[getcwd() . '/' . $sParametro]);
      } 
    }

    self::setArquivos($aArquivos);
  }
  
  public static function status($aParametros = array()) {

    echo Encode::toUTF8("Procurando modificações...\r");

    /**
     * lista dos arquivos adicionados para commit 
     */
    $aArquivos = self::getArquivos();

    exec('cvs -qn update -dR 2> /tmp/cvsupdate', $aRetornoComandoUpdate, $iStatusComandoUpdate);

    if ( $iStatusComandoUpdate > 0 ) {

      self::output('Erro ao execurar cvs -qn update -dR', 'erro');
      //return;
    }

    $lTabela             = false;
    $aArquivosParaCommit = array();

    $aModificacoes = array();

    $aModificados  = array();
    $aCriados      = array();
    $aAtualizados  = array();
    $aConflitos    = array();
    $aAdicionados  = array();
    $aRemovidos    = array();

    $sStatusOutput    = "";
    $sListaUpdate     = "";
    $sListaArquivos   = "";
    $aTipoModificacao = array();

    foreach ($aArquivos as $oCommit) {
      $aArquivosParaCommit[] = self::clearPath($oCommit->sArquivo);
    }

    foreach ($aRetornoComandoUpdate as $sLinhaUpdate) {

      $aLinha = explode(' ', $sLinhaUpdate);
      $oLinha = new StdClass();

      $sTipo = trim($aLinha[0]);

      /**
       * Linha não é um tipo de commit: U, ?, C... 
       */
      if ( !in_array($sTipo, array_keys(self::$aTiposCommit)) ) {
        echo $sTipo . "\n";
        continue;
      }

      $oLinha->sTipo    = "[$sTipo] " . strtr($sTipo, self::$aTiposCommit);
      $oLinha->sArquivo = trim($aLinha[1]);

      /**
       * Array com todas as modificaos
       */
      $aModificacoes[ $sTipo ][] = $oLinha;

      /**
       * Separa em arrays as modificacoes pelo tipo de commit 
       */
      switch ( $sTipo ) { 

        // Novo
        case '?' : 
          $aCriados[] = $oLinha;
        break;

        // Modificado
        case 'M' :
          $aModificados[] = $oLinha;
        break;

        // Conflito
        case 'C' :
          $aConflitos[] = $oLinha;
        break;

        // Atualizado
        case 'U' :
        case 'P' :
          $aAtualizados[] = $oLinha;
        break;

        // Adicionado e nao commitado
        case 'A' :
          $aAdicionados[] = $oLinha;
        break;

        // Removido e nao commitado
        case 'R' :
          $aRemovidos[] = $oLinha;
        break;
      }

    }

    /**
     * Processa parametros 
     */
    foreach ( $aParametros as $sParametro ) {

      switch ($sParametro) {

        case '-table' :
        case '-t' :
          $lTabela = true;
        break;
      } 

    } 

    /**
     * -----------------------------------------------------------------------------
     * Tabela
     * - exibe modificacoes em tabela
     * -----------------------------------------------------------------------------
     */
    if ( $lTabela ) {

      $oTabelaUpdate = new Table();
      $oTabelaUpdate->setHeaders(array('Tipo', 'Arquivo'));

      foreach ($aModificacoes as $aTiposModificacoes) {

        foreach ( $aTiposModificacoes as $sTipo => $oLinhaUpdate ) {

          if ( in_array($oLinhaUpdate->sArquivo, $aArquivosParaCommit) ) {
            continue;
          } 

          $oTabelaUpdate->addRow(array($oLinhaUpdate->sTipo, $oLinhaUpdate->sArquivo));
        }
      }

      if ( count($oTabelaUpdate->getRows()) > 0 ) {

        $oTabelaUpdate->sort(0);
        self::output("Modificacoes não tratadas: ");
        self::output($oTabelaUpdate->render());
      }

      $oTabelaArquivos = new Table();
      $oTabelaArquivos->setHeaders(array('Arquivo', 'Tag', 'Mensagem', 'Tipo'));
      $aLinhas = array();

      foreach ($aArquivos as $oCommit) {
        $oTabelaArquivos->addRow(array(self::clearPath($oCommit->sArquivo), $oCommit->iTag, $oCommit->sMensagem, $oCommit->sTipoCompleto));
      }

      if ( count($oTabelaArquivos->getRows()) > 0 ) {

        self::output("Arquivos prontos para commit: ");
        self::output($oTabelaArquivos->render());
      }

      return;
    } 

    /**
     * -----------------------------------------------------------------------------
     * Linha
     * - exibe modificacoes em linha
     * -----------------------------------------------------------------------------
     */

    /**
     * Novos
     * - arquivos criados e nao adicionados para commit 
     */
    $sArquivosCriados = '';

    foreach ( $aCriados as $oArquivoCriado ) {

      if ( in_array($oArquivoCriado->sArquivo, $aArquivosParaCommit) ) {

        $aTipoModificacao[ realpath($oArquivoCriado->sArquivo) ] = $oArquivoCriado->sTipo;
        continue;
      } 

      $sArquivosCriados .= "\n " . $oArquivoCriado->sArquivo;
    }

    if ( !empty($sArquivosCriados) ) {

      $sStatusOutput .= str_repeat('-', Shell::columns());
      $sStatusOutput .= "\n - Arquivos criados: ";
      $sStatusOutput .= "\n" . str_repeat('-', Shell::columns());
      $sStatusOutput .= "\n " . Shell::colorString($sArquivosCriados, 'brown') . "\n";
    }

    /**
     * Modificados
     * - arquivos modificados e nao adicionados para commit 
     */
    $sArquivosModificados = '';

    foreach ( $aModificados as $oArquivoModificado ) {

      if ( in_array($oArquivoModificado->sArquivo, $aArquivosParaCommit) ) {

        $aTipoModificacao[ realpath($oArquivoModificado->sArquivo) ] = $oArquivoModificado->sTipo;
        continue;
      } 

      $sArquivosModificados .= "\n " . $oArquivoModificado->sArquivo;
    }

    if ( !empty($sArquivosModificados) ) {

      $sStatusOutput .= "\n" . str_repeat('-', Shell::columns());
      $sStatusOutput .= "\n - Arquivos modificados: ";
      $sStatusOutput .= "\n" . str_repeat('-', Shell::columns());
      $sStatusOutput .= "\n " . Shell::colorString($sArquivosModificados, 'red') . "\n";
    }

    /**
     * Conflitos
     * - arquivos com conflito
     */
    $sArquivosConflito = '';

    foreach ( $aConflitos as $oArquivoConflito ) {

      if ( in_array($oArquivoConflito->sArquivo, $aArquivosParaCommit) ) {

        $aTipoModificacao[ realpath($oArquivoConflito->sArquivo) ] = $oArquivoConflito->sTipo;
        continue;
      } 

      $sArquivosConflito .= "\n " . $oArquivoConflito->sArquivo;
    }

    if ( !empty($sArquivosConflito) ) {

      $sStatusOutput .= "\n" . str_repeat('-', Shell::columns());
      $sStatusOutput .= "\n - Arquivos com conflito: ";
      $sStatusOutput .= "\n" . str_repeat('-', Shell::columns());
      $sStatusOutput .= "\n " . Shell::colorString($sArquivosConflito, 'red') . "\n";
    }

    /**
     * Atualizados
     * - arquivos atualizados no repository e nao local
     */
    $sArquivosAtualizados = '';

    foreach ( $aAtualizados as $oArquivoAtualizado ) {

      if ( in_array($oArquivoAtualizado->sArquivo, $aArquivosParaCommit) ) {

        $aTipoModificacao[ realpath($oArquivoAtualizado->sArquivo) ] = $oArquivoAtualizado->sTipo;
        continue;
      } 

      $sArquivosAtualizados .= "\n " . $oArquivoAtualizado->sArquivo;
    }

    if ( !empty($sArquivosAtualizados) ) {

      $sStatusOutput .= "\n" . str_repeat('-', Shell::columns());
      $sStatusOutput .= "\n - Arquivos Atualizados: ";
      $sStatusOutput .= "\n" . str_repeat('-', Shell::columns());
      $sStatusOutput .= "\n " . Shell::colorString($sArquivosAtualizados, 'green') . "\n";
    }

    /**
     * Adicionados
     * - arquivos adicionados e ainda não commitados
     */
    $sArquivosAdicionados = '';

    foreach ( $aAdicionados as $oArquivoAdicionado ) {

      if ( in_array($oArquivoAdicionado->sArquivo, $aArquivosParaCommit) ) {

        $aTipoModificacao[ realpath($oArquivoAdicionado->sArquivo) ] = $oArquivoAdicionado->sTipo;
        continue;
      } 

      $sArquivosAdicionados .= "\n " . $oArquivoAdicionado->sArquivo;
    }

    if ( !empty($sArquivosAdicionados) ) {

      $sStatusOutput .= "\n" . str_repeat('-', Shell::columns());
      $sStatusOutput .= "\n - Arquivos adicionados: ";
      $sStatusOutput .= "\n" . str_repeat('-', Shell::columns());
      $sStatusOutput .= "\n " . Shell::colorString($sArquivosAdicionados, 'green') . "\n";
    }

    /**
     * Removidos
     * - arquivos removidos e ainda não commitados
     */
    $sArquivosRemovidos = '';

    foreach ( $aRemovidos as $oArquivoRemovido ) {

      if ( in_array($oArquivoRemovido->sArquivo, $aArquivosParaCommit) ) {

        $aTipoModificacao[ realpath($oArquivoRemovido->sArquivo) ] = $oArquivoRemovido->sTipo;
        continue;
      } 

      $sArquivosRemovidos .= "\n " . $oArquivoRemovido->sArquivo;
    }

    if ( !empty($sArquivosRemovidos) ) {

      $sStatusOutput .= "\n" . str_repeat('-', Shell::columns());
      $sStatusOutput .= "\n - Arquivos removidos: ";
      $sStatusOutput .= "\n" . str_repeat('-', Shell::columns());
      $sStatusOutput .= "\n " . Shell::colorString($sArquivosRemovidos, 'green') . "\n";
    }

    /**
     * Arquivos para commit 
     */
    foreach ($aArquivos as $oCommit) {

      $sTipoMoficacao = '[*]Modificado';

      if ( !empty($aTipoModificacao[$oCommit->sArquivo]) ) {
        $sTipoMoficacao = $aTipoModificacao[$oCommit->sArquivo];
      } 

      $sListaArquivos .= "\n " . self::clearPath($oCommit->sArquivo) . " ";

      if ( !empty($oCommit->iTag) ) {
        $sListaArquivos .= "#$oCommit->iTag ";
      }

      $sListaArquivos .= $oCommit->sTipoAbreviado;
      $sListaArquivos .= ' ' .$oCommit->sMensagem;
    }

    if ( !empty($sListaArquivos) ) {

      $sStatusOutput .= "\n" . str_repeat('-', Shell::columns());
      $sStatusOutput .= "\n - Arquivos prontos para commit: ";
      $sStatusOutput .= "\n" . str_repeat('-', Shell::columns());
      $sStatusOutput .= "\n " . Shell::colorString($sListaArquivos, 'green') . "\n";
    }

    if ( empty($sStatusOutput) ) {

      self::output('Nenhuma modificação encontrada');
      return;
    }

    self::output($sStatusOutput);
  }

  /**
   * Baixa modificacoes
   *
   * @static
   * @access public
   * @return void
   */
  public static function pull() {

    echo Encode::toUTF8("Baixando atualizações...\r");

    exec('cvs update -dR 2> /tmp/cvspull', $aRetornoComandoUpdate, $iStatusComandoUpdate);

    if ( $iStatusComandoUpdate > 0 ) {
      self::output('Erro ao execurar cvs update -dR', 'erro');
    }

    self::status();
  }

  /**
   * Adiciona arquivo para lista de commit
   *
   * @param array $aArgumentos
   * @static
   * @access public
   * @return void
   */
  public static function adicionar($aArgumentos) {

    $aArquivos = self::getArquivos();

    /**
     * Procura o arquivo
     * @todo aceitar varios arquivos
     */
    foreach ($aArgumentos as $iIndice => $sArgumento) {

      if ( file_exists($sArgumento) && $sArgumento != '.' ) {

        $sArquivo = realpath($sArgumento);
        break;
      }
    }

    /**
     * Arquivo nao iformado, invalido ou eh um diretorio 
     */
    if ( empty($sArquivo) || is_dir($sArquivo) ) {

      self::output("Arquivo para commit nao informado ou invalido", 'aviso');
      return false;
    } 

    /**
     * verifica se ja existe arquivo para esse diretorio 
     * se existe, recupera, caso contrario cria objeto
     */
    if ( !empty($aArquivos) && !empty($aArquivos[$sArquivo]) ) {

      $oParametros = $aArquivos[$sArquivo];

    } else {

      $oParametros = new StdClass();
      $oParametros->sMensagem      = null;
      $oParametros->iTag           = null;
      $oParametros->sTipoAbreviado = null;
      $oParametros->sTipoCompleto  = null;
    }

    $oParametros->sArquivo = $sArquivo;

    /**
     * Percorre os argumentos e monta parametros para commit 
     */
    foreach ($aArgumentos as $iIndice => $sArgumento) {

      switch ( $sArgumento ) {
        
        /**
         * Mensagem do commit 
         */
        case '-m' :
        case '-msg' :
        case '-mensagem' :

          $iProximoIndice = $iIndice + 1;
          $oParametros->sMensagem = $aArgumentos[$iProximoIndice];
          continue;

        break;

        /**
         * Tag do commit 
         */
        case '-t' :
        case '-tag' :

          $iProximoIndice = $iIndice + 1;
          if ( empty($aArgumentos[$iProximoIndice]) || strpos($aArgumentos[$iProximoIndice], '-') !== false ) {
            continue;
          }
          $oParametros->iTag = $aArgumentos[$iProximoIndice];
          continue;

        break;

        /**
         * Commit para melhorias 
         */
        case '-e' :
        case '-enh' :
        case '-enhanced' :

          $oParametros->sTipoAbreviado = 'ENH';
          $oParametros->sTipoCompleto = 'enhanced';
          continue;

        break;

        /**
         * Commit para correcao de erros 
         */ 
        case '-f' :
        case '-fix' :
        case '-fixed' :

          $oParametros->sTipoAbreviado = 'FIX';
          $oParametros->sTipoCompleto = 'fixed';
          continue;

        break;

        /**
         * Commit para adicionar fonte ou funcionalidade
         */
        case '-a' :
        case '-add' :
        case '-added' :

          $oParametros->sTipoAbreviado = 'ADD';
          $oParametros->sTipoCompleto = 'added';
          continue;

        break;

        /**
         * Commit para modificacoes do layout ou documentacao 
         */
        case '-s' :
        case '-style' :

          $oParametros->sTipoAbreviado = 'STYLE';
          $oParametros->sTipoCompleto = 'style';
          continue;

        break;

      }

    }

    $aArquivos[ $oParametros->sArquivo ] = $oParametros;
    self::setArquivos($aArquivos);
  }

  static function clearPath($sPath) {
    return str_replace( getcwd() . '/', '', $sPath );
  }

}

class Table {

	protected $aHeaders = array();
	protected $aWidht   = array();
	protected $aRows    = array();

	public function __construct(array $headers = null, array $rows = null) {

		if ( !empty($headers) ) {
			$this->setHeaders($headers);
		}

    if ( !empty($rows) ) {
			  $this->setRows($rows);
    }
	}

	protected function checkRow(array $row) {

		foreach ($row as $column => $str) {

			$width = Shell::strlen($str);

			if (!isset($this->aWidth[$column]) || $width > $this->aWidth[$column]) {
				$this->aWidth[$column] = $width;
			}
		}

		return $row;
	}

	public function render( $lEspacos = false ) {
		
		$borderStr = '';
    $sTabela = '';

    if ( !$lEspacos ) {

      foreach ($this->aHeaders as $column => $header) {
      
        if ( $column > 0 ) {
          $borderStr .= '+';
        }
      
      	$borderStr .= '-' . str_repeat('-', $this->aWidth[$column]) . '-';
      }

      $sTabela  = "\n" . $this->renderRow($this->aHeaders);
      $sTabela .= "\n" . $borderStr;
    }

		foreach ($this->aRows as $row) {
			$sTabela .= "\n" . $this->renderRow($row, $lEspacos);
		}

    return $sTabela . "\n";
	}

	protected function renderRow(array $row, $lEspacos = false) {

		$render = '';

		foreach ($row as $column => $val) {

      $render .= '';

      if ( $column > 0 && !$lEspacos ) {
		    $render .= '|';
      }

      if ( !$lEspacos) {
			  $render .= ' ';
      } 

			$render .= Shell::str_pad($val, $this->aWidth[$column]) . ' ';
		}

		return $render;
	}

	public function sort($column) {

		if (!isset($this->aHeaders[$column])) {

			trigger_error('Coluna invalida no index ' . $column, E_USER_NOTICE);
			return;
		}

		usort($this->aRows, function($a, $b) use ($column) {
			return strcmp($a[$column], $b[$column]);
		});
	}

	public function setHeaders(array $headers) {
		$this->aHeaders = $this->checkRow($headers);
	}

	public function addRow(array $row) {
		$this->aRows[] = $this->checkRow($row);
	}

	public function setRows(array $rows) {

		$this->aRows = array();

		foreach ($rows as $row) {
			$this->addRow($row);
		}
	}

	public function getRows() {
		return $this->aRows;
	}

}

class Shell {

  /**
   * Array de cores do terminal 
   */
  private static $aColors = array(
    'light_red'   => '[1;31m',
    'light_green' => '[1;32m',
    'yellow'      => '[1;33m',
    'light_blue'  => '[1;34m',
    'magenta'     => '[1;35m',
    'light_cyan'  => '[1;36m',
    'white'       => '[1;37m',
    'normal'      => '[0m',
    'black'       => '[0;30m',
    'red'         => '[0;31m',
    'green'       => '[0;32m',
    'brown'       => '[0;33m',
    'blue'        => '[0;34m',
    'cyan'        => '[0;36m',
    'bold'        => '[1m',
    'underscore'  => '[4m',
    'reverse'     => '[7m'
  );

	/**
   * Retorna o numero de colunas do atual shell 
	 * @return int numero de colunas
	 */
	static public function columns() {
		return exec('/usr/bin/env tput cols');
	}

  /**
   * Retorna uma string colorida
   * - ao usar less, se nao colorir, usar export LESS="-erX"
   *
   * @param string $sText
   * @param string $sColor
   * @static
   * @access public
   * @return string
   */
  static public function colorString($sText, $sColor = 'normal') {

    $sOutput = self::$aColors[ strtolower($sColor) ];

    if ($sOutput == "") {
      $sOutput = "[0m"; 
    }

    return chr(27) . $sOutput. $sText . chr(27) . "[0m";
  }

  /**
   * Retorna o o tamanho da string sem contar as cores
   *
   * @param string $sText
   * @static
   * @access public
   * @return integer
   */
  static public function strlen($sValue) {

    $aColors      = array_merge( array_values(self::$aColors), array("[0m", chr(27)) );
    $sStripColors = str_replace($aColors, '', $sValue);

    return mb_strlen($sStripColors, 'utf8');
  }

  /**
   * Retorna string para strings que contem cor 
   *
   * @param string $sString
   * @param integer $iLength
   * @static
   * @access public
   * @return string
   */
	static public function str_pad($sString, $iLength) {

		$iRealLength = mb_strlen($sString, 'utf8');
		$iShowLength = self::strlen($sString);
		$iLength    += $iRealLength - $iShowLength;

		return str_pad($sString, $iLength);
	}

}

class Encode {

  static public function ISOToUTF8($sText) {
    return mb_convert_encoding($sText, 'UTF-8', 'ISO-8859-1'); 
  }

  static public function UTF8ToISO($sText) {
    return mb_convert_encoding($sText, 'ISO-8859-1', 'UTF-8'); 
  }

  static public function toUTF8($sText) {
    return mb_convert_encoding($sText, "UTF-8", mb_detect_encoding($sText, "UTF-8, ISO-8859-1, ISO-8859-15", true));
  }

  static public function toISO($sText) {
    return mb_convert_encoding($sText, "ISO-8859-1", mb_detect_encoding($sText, "UTF-8, ISO-8859-1, ISO-8859-15", true)); 
  }

}

