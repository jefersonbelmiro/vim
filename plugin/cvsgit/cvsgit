#!/usr/bin/php -q 
<?php
/**
 * -----------------------------------------------------------------------------
 * cvsgit - Algumas Funcionalidas do GIT para CVS
 * -----------------------------------------------------------------------------
 *
 * @todo - metodo push, verificar usando cvs -qn update para verificar se arquivo ja existe
 *         para usar cvs add nome_aquivo
 * @todo - comentar tudo
 * @todo - separar classes em arquivos
 * @todo - criar metodos para reaproveitar codigo
 * @todo - remover statics, utilizar instancia da classe CvsGit
 *
 * @require phpcli
 * @require cvs client
 * @version 0.1
 * -----------------------------------------------------------------------------
 */

/**
 * remove primeiro indice com nome do arquivo atual 
 */
array_shift($argv);

/**
 * argumentos passados para o script
 */
$aArgumentos = $argv;

/**
 * Opcao a ser executada
 */
$sOpcao = array_shift($aArgumentos);

/**
 * verifica qual metodo chamar 
 */
switch ($sOpcao) {

  default : 

    CvsGit::output("Nenhum comando informado", 'aviso');
    CvsGit::output(" Usar: cvsgit [comando] [opcoes do comando]");
    CvsGit::output(" Comandos: status, add, init, push, pull, rm e log\n");

  break;

  case 'status' :
    CvsGit::status($aArgumentos);
  break;

  case 'add':
  case 'commit':
    CvsGit::adicionar($aArgumentos);
  break;

  case 'init':
    CvsGit::iniciar($aArgumentos);
  break;

  case 'log':
    CvsGit::log($aArgumentos);
  break;

  case 'rm':
    CvsGit::remover($aArgumentos);
  break;

  case 'push' :
    CvsGit::push();
  break;

  case 'pull' :
    CvsGit::pull();
  break;
}

class CvsGit {
  
  public static $sDiretorioObjetos = '/home/jeferson/.vim/plugin/cvsgit/objects/';

  /**
   * Tipos de commit  
   */
  public static $aTipoCommit = array(

    /**
     * Tem arquivo no projeto mas nao no servidor, cvs add
     */
    '?' => 'Novo', 

    /**
     * Tem alteracoes que nao tem no servidor 
     */
    'M' => 'Modificado',

    /**
     * Conflito, e cvs tentou fazer merge
     * cvs altera arquivo colocando as diferencas 
     */
    'C' => 'Modificado',

    /**
     * modificado no servidor
     * versao do servidor é maior que a do projeto 
     */
    'U' => 'Atualizado',

    /**
     * Igual U, diferenca que servidor manda um path 
     */
    'P' => 'Atualizado',

    /**
     * Apos dar cvs add, arquivo pronto para ser comitado 
     */
    'A' => 'Adicionado',

    /**
     * Apos remover arquivo do projeto, ira remover do servidor se for commitado 
     */
    'R' => '-Removido'
  );

  public static function output($sMensagem, $sPerfil = null) {

    switch( $sPerfil ) {

      case 'erro' :
        $sMensagem = "\n " . $sMensagem . "\n";
      break;

      case 'aviso' : 
        $sMensagem = "\n " . $sMensagem . "\n";
      break;
    }

    echo $sMensagem . "\n";
  }

  private static function getArquivos() {
    
    $sDiretorioObjetos = self::$sDiretorioObjetos . md5(getcwd());

    if ( !file_exists($sDiretorioObjetos) ) {

      self::output(getcwd() . " nao inicializado");
      exit(1);
    }

    return unserialize(file_get_contents($sDiretorioObjetos));
  }

  private static function setArquivos(Array $aArquivos) {

    $sDiretorioObjetos = self::$sDiretorioObjetos . md5(getcwd());

    return file_put_contents($sDiretorioObjetos, serialize($aArquivos));
  }

  /**
   * Inicia um projeto
   *
   * @static
   * @access public
   * @return void
   */
  public static function iniciar($aParametros = array()) {
    self::setArquivos(array());
  }

  /**
   * log
   *
   * @static
   * @access public
   * @return void
   */
  public static function log($aParametros) {

    if ( empty($aParametros) ) {

      self::output('Nenhum parametro informado');
      return;
    }

    // @todo aceitar varios arquivos
    foreach ($aParametros as $iIndice => $sParametro) {

      if ( file_exists($sParametro) ) {

        $sArquivo = $sParametro;
        break;
      }
    }

    if ( empty($sArquivo) ) {

      self::output('arquivo nao econtrado');
      return;
    } 

    $sArquivo = str_replace(getcwd() . '/', '', $sArquivo);

    /**
     * Lista somenta as tags
     */
    exec('cvs log -h ' . $sArquivo . ' 2> /tmp/cvslog-header-error', $aRetornoComandoTags, $iStatusComandoTags);

    if ( $iStatusComandoTags > 0 ) {

      self::output('Erro ao execurar cvs log -h ' . $sArquivo, 'erro');
      return;
    }

    $aTagsPorVersao = array();
    $iVersaoAtual = 0;
    $lInicioListaTags = false;

    foreach( $aRetornoComandoTags as $iIndiceTags => $sLinhaRetornoTag ) {

      if ( strpos($sLinhaRetornoTag, 'head:') !== false ) {

        $iVersaoAtual = trim(str_replace('head:', '', $sLinhaRetornoTag));
        continue;
      }

      if ( strpos($sLinhaRetornoTag, 'symbolic names:') !== false ) {

        $lInicioListaTags = true;
        continue;
      }

      if ( $lInicioListaTags ) {

        if ( strpos($sLinhaRetornoTag, 'keyword substitution') !== false ) {
          break;
        }

        if ( strpos($sLinhaRetornoTag, 'total revisions') !== false ) {
          break;
        }

        $aLinhaTag = explode(':', $sLinhaRetornoTag);
        $iVersao   = trim($aLinhaTag[1]);
        $sTag      = trim($aLinhaTag[0]);

        $aTagsPorVersao[$iVersao][] = $sTag;
      }
    }

    /**
     * Lista informacoes do commit, sem as tags
     */
    exec('cvs log -N ' . $sArquivo . ' 2> /tmp/cvslog-info-error', $aRetornoComandoInformacoes, $iStatusComandoInformacoes);

    if ( $iStatusComandoInformacoes > 0 ) {

      self::output('Erro ao execurar cvs log -N ' . $sArquivo, 'erro');
      return;
    }

    $aLog = array();
    $iLinhaInformacaoCommit = 0;

    $oTabela = new Table();
    $oTabela->setHeaders(array('Autor', 'Data', 'Versao', 'Tag', 'Mensagem'));
    $aLinhas = array();

    $iVersao   = null;
    $sAutor    = null;
    $sData     = null;
    $sMensagem = null;

    foreach ( $aRetornoComandoInformacoes as $iIndice => $sLinhaRetorno ) {

      if ( strpos($sLinhaRetorno, '------') !== false ) {
        continue;
      } 

      if ( $iLinhaInformacaoCommit == 0 && $iIndice > 11 ) {

        $sTagsPorVersao = null;

        if ( !empty($aTagsPorVersao[$iVersao]) ) {
          //$sTagsPorVersao = implode(', ', $aTagsPorVersao[$iVersao]);
          $sTagsPorVersao = count($aTagsPorVersao[$iVersao]);
        }

        if ( $iVersao == $iVersaoAtual ) {
          $iVersao .= '*';
        } 

        $oTabela->addRow(array($sAutor, $sData, $iVersao, $sTagsPorVersao, $sMensagem));
        $iVersao   = '';
        $sAutor    = '';
        $sData     = '';
        $sMensagem = '';
      }

      if ( $iLinhaInformacaoCommit > 0 ) {
        $iLinhaInformacaoCommit--;
      } 

      /**
       * Versao
       */
      if ( strpos($sLinhaRetorno, 'revision') !== false && strpos($sLinhaRetorno, 'revision') === 0 ) {
        $iLinhaInformacaoCommit = 2;
      } 
      
      /**
       * Versao
       */
      if ( $iLinhaInformacaoCommit == 2 ) {

        $iVersao = trim(str_replace('revision', '', $sLinhaRetorno));
        continue;
      }

      /**
       * Data e autor 
       */
      if ( $iLinhaInformacaoCommit == 1 ) {
        
        $sLinhaRetorno = strtr($sLinhaRetorno, array('date:' => '', 'author:' => ''));
        $aLinhaInformacoesCommit = explode(';', $sLinhaRetorno);
        $sLinhaData = array_shift($aLinhaInformacoesCommit);
        $aLinhaData = explode(' ', $sLinhaData);
        $sData .= implode('/', array_reverse(explode('/', $aLinhaData[1])));

        $sAutor = trim(array_shift($aLinhaInformacoesCommit));
        continue;
      } 

      /**
       * Mensagem 
       */
      if ( $iLinhaInformacaoCommit == 0 ) {
        $sMensagem = $sLinhaRetorno;
      }
    }

    self::output($oTabela->render());
  }

  public static function push() {

    $aArquivos = self::getArquivos();

    if ( empty($aArquivos) ) {

      self::output("Nenhum arquivo para comitar");
      return;
    }

    $oTabela = new Table();
    $oTabela->setHeaders(array('Arquivo', 'Tag', 'Mensagem', 'Tipo'));
    $aLinhas = array();
    $aComandos = array();
    $iErros  = 0;

    foreach ( $aArquivos as $oCommit ) {

      $sArquivo      = $oCommit->sArquivo;
      $iTag          = $oCommit->iTag;
      $sMensagem     = $oCommit->sMensagem;
      $sTipoCompleto = $oCommit->sTipoCompleto;
      $sErro         = Shell::colorString('[x]', 'red');

      if ( !file_exists($oCommit->sArquivo) ) {

        $sArquivo = $sErro . $oCommit->sArquivo;
        $iErros++;
      }

      if ( empty($oCommit->sMensagem) ) {

        $sMensagem = $sErro;
        $iErros++;
      }

      if ( empty($oCommit->iTag) || strlen($oCommit->iTag) < 4 ) {

        $iTag = $sErro;
        $iErros++;
      }

      if ( empty($oCommit->sTipoAbreviado) || empty($oCommit->sTipoCompleto) ) {

        $sTipoCompleto = $sErro;
        $iErros++;
      }

      $oTabela->addRow(array($sArquivo, $iTag, $sMensagem, $sTipoCompleto));

      $aComandos[ $oCommit->sArquivo ][] = $oCommit;
    }

    if ( $iErros > 0 ) {

      self::output("\n " . $iErros . " erro(s) encontrado(s):");
      self::output($oTabela->render());
      return;
    }

    echo "\n";

    foreach($aComandos as $sArquivo => $aCommits) {

      foreach($aCommits as $oCommit) {

        $sComandoCommit = "cvs commit -m '$oCommit->sTipoAbreviado: $oCommit->sMensagem ($oCommit->sTipoCompleto #$oCommit->iTag)' $oCommit->sArquivo";
        $sComandoTag    = "cvs tag -F T{$oCommit->iTag} $oCommit->sArquivo";

        self::output("$sArquivo: ");
        self::output("   " . $sComandoCommit);
        self::output("   " . $sComandoTag);
        //system($sComandoCommit);
        //system($sComandoTag);
      }

      echo "\n";
    }

  }

  /**
   * Remover arquivo da lista de arquivos para commit
   *
   * @param Array $aParametros
   * @static
   * @access public
   * @return void
   */
  public static function remover($aParametros) {

    $aArquivos = self::getArquivos();

    foreach ( $aParametros as $sParametro ) {

      if ( in_array($sParametro, array('.', '*', 'all')) ) {

        $aArquivos = array();
        break;
      }

      if ( !empty($aArquivos[$sParametro]) || in_array($sParametro, array('.', '*', 'all')) ) {
        unset($aArquivos[$sParametro]);
      }
    }

    self::setArquivos($aArquivos);
  }
  
  public static function status($aParametros = array()) {

    /**
     * lista dos arquivos adicionados para commit 
     */
    $aArquivos = self::getArquivos();

    exec('cvs -qn update -dR 2> /tmp/cvsupdate', $aRetornoComandoUpdate, $iStatusComandoUpdate);

    if ( $iStatusComandoUpdate > 0 ) {

      self::output('Erro ao execurar cvs -qn update -dR', 'erro');
      return;
    }

    $aArquivosParaCommit = array();
    $aLinhaUpdate        = array();

    $sStatusOutput    = "";
    $sListaUpdate     = "";
    $sListaArquivos   = "";
    $aTipoModificacao = array();

    foreach ($aArquivos as $oCommit) {
      $aArquivosParaCommit[] = $oCommit->sArquivo;
    }

    foreach ($aRetornoComandoUpdate as $sLinhaUpdate) {

      $aLinha = explode(' ', $sLinhaUpdate);
      $oLinha = new StdClass();

      $oLinha->sTipo    = strtr(trim($aLinha[0]), self::$aTipoCommit);
      $oLinha->sArquivo = trim($aLinha[1]);

      $aLinhaUpdate[] = $oLinha;
    }

    foreach ( $aParametros as $sParametro ) {

      switch ($sParametro) {

        case '-table' :
        case '-t' :

          $oTabelaUpdate = new Table();
          $oTabelaUpdate->setHeaders(array('Tipo', 'Arquivo'));

          foreach ($aLinhaUpdate as $oLinhaUpdate) {

            if ( in_array($oLinhaUpdate->sArquivo, $aArquivosParaCommit) ) {
              continue;
            } 

            $oTabelaUpdate->addRow(array($oLinhaUpdate->sTipo, $oLinhaUpdate->sArquivo));
          }

          if ( count($oTabelaUpdate->getRows()) > 0 ) {

            self::output("Modificacoes não tratadas: ");
            self::output($oTabelaUpdate->render());
          }

          $oTabelaArquivos = new Table();
          $oTabelaArquivos->setHeaders(array('Arquivo', 'Tag', 'Mensagem', 'Tipo'));
          $aLinhas = array();

          foreach ($aArquivos as $oCommit) {
            $oTabelaArquivos->addRow(array($oCommit->sArquivo, $oCommit->iTag, $oCommit->sMensagem, $oCommit->sTipoCompleto));
          }

          if ( count($oTabelaArquivos->getRows()) > 0 ) {

            self::output("Arquivos prontos para commit: ");
            self::output($oTabelaArquivos->render());
          }

          return;

        break;
      } 

    } 

    /**
     * exibe modificacoes em linha
     */

    foreach ($aLinhaUpdate as $oLinhaUpdate) {

      if ( in_array($oLinhaUpdate->sArquivo, $aArquivosParaCommit) ) {

        $aTipoModificacao[ $oLinhaUpdate->sArquivo ] = $oLinhaUpdate->sTipo;
        continue;
      } 

      $sListaUpdate .= "\n " . str_pad($oLinhaUpdate->sTipo, 13, ' ') .': ' . $oLinhaUpdate->sArquivo;
    }

    if ( !empty($sListaUpdate) ) {

      $sStatusOutput .= "Modificacoes não tratadas: ";
      $sStatusOutput .= "\n " . Shell::colorString($sListaUpdate, 'red') . "\n";
    }

    foreach ($aArquivos as $oCommit) {

      $sTipoMoficacao = '[*]Modificado';

      if ( !empty($aTipoModificacao[$oCommit->sArquivo]) ) {
        $sTipoMoficacao = $aTipoModificacao[$oCommit->sArquivo];
      } 

      $sListaArquivos .= "\n " . str_pad($sTipoMoficacao, 13, ' ') .': ' . $oCommit->sArquivo . " ";

      if ( !empty($oCommit->iTag) ) {
        $sListaArquivos .= "#$oCommit->iTag ";
      }

      $sListaArquivos .= $oCommit->sTipoAbreviado;
    }

    if ( !empty($sListaArquivos) ) {

      $sStatusOutput .= "\nArquivos prontos para commit: ";
      $sStatusOutput .= "\n " . Shell::colorString($sListaArquivos, 'green') . "\n";
    }

    if ( empty($sStatusOutput) ) {

      self::output('Nenhuma modificacao encontrada');
      return;
    }

    self::output($sStatusOutput);
  }

  public static function pull() {

    exec('cvs update -dR 2> /tmp/cvspull', $aRetornoComandoUpdate, $iStatusComandoUpdate);

    if ( $iStatusComandoUpdate > 0 ) {

      self::output('Erro ao execurar cvs update -dR', 'erro');
      return;
    }

    self::status();
  }

  public static function adicionar($aArgumentos) {

    $aArquivos = self::getArquivos();

    /**
     * Procura o arquivo
     * @todo aceitar varios arquivos
     */
    foreach ($aArgumentos as $iIndice => $sArgumento) {

      if ( file_exists($sArgumento) && $sArgumento != '.' ) {

        $sArquivo = str_replace(getcwd() . '/', '', $sArgumento);
        break;
      }
    }

    /**
     * Arquivo nao iformado, invalido ou eh um diretorio 
     */
    if ( empty($sArquivo) || is_dir($sArquivo) ) {

      self::output("Arquivo para commit nao informado ou invalido", 'aviso');
      return false;
    } 

    /**
     * verifica se ja existe arquivo para esse diretorio 
     * se existe, recupera, caso contrario cria objeto
     */
    if ( !empty($aArquivos) && !empty($aArquivos[$sArquivo]) ) {

      $oParametros = $aArquivos[$sArquivo];

    } else {

      $oParametros = new StdClass();
      $oParametros->sMensagem      = null;
      $oParametros->iTag           = null;
      $oParametros->sTipoAbreviado = null;
      $oParametros->sTipoCompleto  = null;
    }

    $oParametros->sArquivo = $sArquivo;

    /**
     * Percorre os argumentos e monta parametros para commit 
     */
    foreach ($aArgumentos as $iIndice => $sArgumento) {

      switch ( $sArgumento ) {
        
        /**
         * Mensagem do commit 
         */
        case '-m' :
        case '-msg' :
        case '-mensagem' :

          $iProximoIndice = $iIndice + 1;
          $oParametros->sMensagem = $aArgumentos[$iProximoIndice];
          continue;

        break;

        /**
         * Tag do commit 
         */
        case '-t' :
        case '-tag' :

          $iProximoIndice = $iIndice + 1;
          if ( empty($aArgumentos[$iProximoIndice]) || strpos($aArgumentos[$iProximoIndice], '-') !== false ) {
            continue;
          }
          $oParametros->iTag = $aArgumentos[$iProximoIndice];
          continue;

        break;

        /**
         * Commit para melhorias 
         */
        case '-e' :
        case '-enh' :
        case '-enhanced' :

          $oParametros->sTipoAbreviado = 'ENH';
          $oParametros->sTipoCompleto = 'enhanced';
          continue;

        break;

        /**
         * Commit para correcao de erros 
         */ 
        case '-f' :
        case '-fix' :
        case '-fixed' :

          $oParametros->sTipoAbreviado = 'FIX';
          $oParametros->sTipoCompleto = 'fixed';
          continue;

        break;

        /**
         * Commit para adicionar fonte ou funcionalidade
         */
        case '-a' :
        case '-add' :
        case '-added' :

          $oParametros->sTipoAbreviado = 'ADD';
          $oParametros->sTipoCompleto = 'added';
          continue;

        break;

        /**
         * Commit para modificacoes do layout ou documentacao 
         */
        case '-s' :
        case '-style' :

          $oParametros->sTipoAbreviado = 'STYLE';
          $oParametros->sTipoCompleto = 'style';
          continue;

        break;

      }

    }

    $aArquivos[ $oParametros->sArquivo ] = $oParametros;
    self::setArquivos($aArquivos);
  }

}

class Table {

	protected $aHeaders = array();
	protected $aWidht   = array();
	protected $aRows    = array();

	public function __construct(array $headers = null, array $rows = null) {

		if ( !empty($headers) ) {
			$this->setHeaders($headers);
		}

    if ( !empty($rows) ) {
			  $this->setRows($rows);
    }
	}

	protected function checkRow(array $row) {

		foreach ($row as $column => $str) {

			$width = Shell::strlen($str);

			if (!isset($this->aWidth[$column]) || $width > $this->aWidth[$column]) {
				$this->aWidth[$column] = $width;
			}
		}

		return $row;
	}

	public function render() {
		
		$borderStr = '';

		foreach ($this->aHeaders as $column => $header) {

      if ( $column > 0 ) {
		    $borderStr .= '+';
      }

			$borderStr .= '-' . str_repeat('-', $this->aWidth[$column]) . '-';
		}

		$sTabela  = "\n" . $this->renderRow($this->aHeaders);
		$sTabela .= "\n" . $borderStr;

		foreach ($this->aRows as $row) {
			$sTabela .= "\n" . $this->renderRow($row);
		}

    return $sTabela . "\n";
	}

	protected function renderRow(array $row) {

		$render = '';

		foreach ($row as $column => $val) {

      if ( $column > 0 ) {
		    $render .= '|';
      }

			$render .= ' ' . Shell::str_pad($val, $this->aWidth[$column]) . ' ';
		}

		return $render;
	}

	public function sort($column) {

		if (!isset($this->aHeaders[$column])) {

			trigger_error('Coluna invalida no index ' . $column, E_USER_NOTICE);
			return;
		}

		usort($this->aRows, function($a, $b) use ($column) {
			return strcmp($a[$column], $b[$column]);
		});
	}

	public function setHeaders(array $headers) {
		$this->aHeaders = $this->checkRow($headers);
	}

	public function addRow(array $row) {
		$this->aRows[] = $this->checkRow($row);
	}

	public function setRows(array $rows) {

		$this->aRows = array();

		foreach ($rows as $row) {
			$this->addRow($row);
		}
	}

	public function getRows() {
		return $this->aRows;
	}

}

class Shell {

  /**
   * Array de cores do terminal 
   */
  private static $aColors = array(
    'light_red'   => '[1;31m',
    'light_green' => '[1;32m',
    'yellow'      => '[1;33m',
    'light_blue'  => '[1;34m',
    'magenta'     => '[1;35m',
    'light_cyan'  => '[1;36m',
    'white'       => '[1;37m',
    'normal'      => '[0m',
    'black'       => '[0;30m',
    'red'         => '[0;31m',
    'green'       => '[0;32m',
    'brown'       => '[0;33m',
    'blue'        => '[0;34m',
    'cyan'        => '[0;36m',
    'bold'        => '[1m',
    'underscore'  => '[4m',
    'reverse'     => '[7m'
  );

	/**
   * Retorna o numero de colunas do atual shell 
	 * @return int numero de colunas
	 */
	static public function columns() {
		return exec('/usr/bin/env tput cols');
	}

  /**
   * Retorna uma string colorida
   * - ao usar less, se nao colorir, usar export LESS="-erX"
   *
   * @param string $sText
   * @param string $sColor
   * @static
   * @access public
   * @return string
   */
  static public function colorString($sText, $sColor = 'normal') {

    $sOutput = self::$aColors[ strtolower($sColor) ];

    if ($sOutput == "") {
      $sOutput = "[0m"; 
    }

    return chr(27) . $sOutput. $sText . chr(27) . "[0m";
  }

  /**
   * Retorna o o tamanho da string sem contar as cores
   *
   * @param string $sText
   * @static
   * @access public
   * @return integer
   */
  static public function strlen($sValue) {

    $aColors      = array_merge( array_values(self::$aColors), array("[0m", chr(27)) );
    $sStripColors = str_replace($aColors, '', $sValue);

    return strlen($sStripColors);
  }

  /**
   * Retorna string para strings que contem cor 
   *
   * @param string $sString
   * @param integer $iLength
   * @static
   * @access public
   * @return string
   */
	static public function str_pad($sString, $iLength) {

		$iRealLength = strlen($sString);
		$iShowLength = self::strlen($sString);
		$iLength    += $iRealLength - $iShowLength;

		return str_pad($sString, $iLength);
	}

}

